"""backend/server.py

Generated by Codex CLI
Updated: 2025-09-07
Desc: Bootstrap FastAPI server. Initialize databases, CORS, logging and router loading.
"""

import importlib
import os
import pkgutil
from configparser import ConfigParser

try:
    from . import router as router  # when imported as package
except Exception:  # pragma: no cover
    import router  # when running from backend/ working dir

from fastapi import FastAPI, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from starlette.middleware.sessions import SessionMiddleware

# Support both package import (backend.server) and module import (server)
try:  # package context
    from .lib.Auth import AuthConfig  # type: ignore
    from .lib.Database import (  # type: ignore
        DatabaseManager,
        loadQueries,
        sqlObserver,
        startWatchingQueryFolder,
        setQueryConfig,
    )
    from .lib import Database as DB  # type: ignore
    from .lib.Logger import logger  # type: ignore
    from .lib.Response import errorResponse  # type: ignore
    from .lib.Middleware import RequestLogMiddleware  # type: ignore
    from .lib.OpenAPI import attachOpenAPI  # type: ignore
except Exception:  # module context
    from lib.Auth import AuthConfig
    from lib.Database import (
        DatabaseManager,
        loadQueries,
        sqlObserver,
        startWatchingQueryFolder,
        setQueryConfig,
    )
    from lib import Database as DB
    from lib.Logger import logger
    from lib.Response import errorResponse
    from lib.Middleware import RequestLogMiddleware
    from lib.OpenAPI import attachOpenAPI

app = FastAPI()

# ---------------------------------------------------------------------------
# Config helpers
# ---------------------------------------------------------------------------


def loadConfig(filename: str) -> ConfigParser:
    """Read configuration file relative to this module."""
    logger.info("config load start")
    config = ConfigParser()
    base_dir = os.path.dirname(__file__)
    cfg_path = filename
    if not os.path.isabs(filename):
        cfg_path = os.path.join(base_dir, filename)
    with open(cfg_path, "r", encoding="utf-8") as f:
        config.read_file(f)
    logger.info("config load done")
    return config


async def onShutdown():
    """Cleanup on application shutdown."""
    for manager in DB.dbManagers.values():
        if hasattr(manager, "disconnect"):
            await manager.disconnect()
    if sqlObserver:
        sqlObserver.stop()
        sqlObserver.join()


# ---------------------------------------------------------------------------
# Startup tasks
# ---------------------------------------------------------------------------


async def onStartup():
    """Initialise databases, query loader and auth config."""
    logger.info("database connect start")
    global sqlObserver

    dbSections = [s for s in config.sections() if s.startswith("DATABASE")]

    for section in dbSections:
        dbConfig = config[section]
        dbName = dbConfig.get("name", section.lower())
        dbType = dbConfig.get("type")

        # skip if already provided
        if dbName in DB.dbManagers:
            continue

        if dbType == "sqlite":
            dbPath = dbConfig.get("database")
            base_dir = os.path.dirname(__file__)
            if not os.path.isabs(dbPath):
                dbPath = os.path.join(base_dir, dbPath)
            os.makedirs(os.path.dirname(dbPath), exist_ok=True)
            dbUrl = f"sqlite:///{dbPath}"
        elif dbType in ["mysql", "mariadb"]:
            host = dbConfig.get("host", "localhost")
            port = dbConfig.get("port", "3306")
            database = dbConfig.get("database")
            user = dbConfig.get("user")
            password = dbConfig.get("password")
            dbUrl = f"mysql+pymysql://{user}:{password}@{host}:{port}/{database}"
        elif dbType == "postgresql":
            host = dbConfig.get("host", "localhost")
            port = dbConfig.get("port", "5432")
            database = dbConfig.get("database")
            user = dbConfig.get("user")
            password = dbConfig.get("password")
            dbUrl = f"postgresql://{user}:{password}@{host}:{port}/{database}"
        else:
            logger.warning(f"unsupported database type: {dbType}")
            continue

        try:
            if dbName not in DB.dbManagers or not getattr(DB.dbManagers[dbName], "databaseUrl", None):
                DB.dbManagers[dbName] = DatabaseManager(dbUrl)
            if hasattr(DB.dbManagers[dbName], "connect"):
                await DB.dbManagers[dbName].connect()
            logger.info(f"database connected: {dbName}")
        except Exception as e:
            logger.error(f"database connect failed ({dbName}): {str(e)}")

    logger.info("database connect done")
    logger.info("query load start")

    # query loader
    try:
        dbGlobal = config["DATABASE"]
    except Exception:
        dbGlobal = None

    base_dir = os.path.dirname(__file__)
    repo_root = os.path.dirname(base_dir)
    qdir_raw = (dbGlobal.get("query_dir") if dbGlobal else None) or "query"
    if not os.path.isabs(qdir_raw):
        norm = qdir_raw.replace("\\", "/")
        if norm.startswith("backend/"):
            qdir_abs = os.path.join(repo_root, qdir_raw)
        else:
            qdir_abs = os.path.join(base_dir, qdir_raw)
    else:
        qdir_abs = qdir_raw

    qwatch = True
    try:
        qwatch = dbGlobal.getboolean("query_watch", True) if dbGlobal else True
    except Exception:
        pass

    try:
        qdebounce = dbGlobal.getint("query_watch_debounce_ms", 150) if dbGlobal else 150
    except Exception:
        qdebounce = 150

    setQueryConfig(qdir_abs, qwatch, qdebounce)

    loadQueries()
    logger.info("query load done")
    sqlObserver = startWatchingQueryFolder()
    if sqlObserver:
        logger.info("query watcher started")

    # load auth config
    authConfig = config["AUTH"]
    AuthConfig.initConfig(
        secretKey=authConfig["secret_key"],
        expireMinutes=authConfig.getint("token_expire", 3600) // 60,
        tokenEnable=authConfig.getboolean("token_enable", True),
    )

    # Note: User table creation/seeding is handled by scripts/tests or AuthService.
    # Avoid implicit DDL/DML on startup to respect external DBs.

    try:
        attachOpenAPI(app, config)
    except Exception:
        pass


# ---------------------------------------------------------------------------
# Application setup
# ---------------------------------------------------------------------------

config = loadConfig("config.ini")
# expose primary DB name to DB helper for non-hardcoded access
try:
    from .lib import Database as DB  # type: ignore
except Exception:
    from lib import Database as DB
try:
    DB.setPrimaryDbName(config["DATABASE"].get("name", "main_db"))
except Exception:
    pass

# CORS config
origins_raw = config["CORS"].get("allow_origins", "").strip()
if origins_raw == "*":
    origins = [os.getenv("DEV_WEB_ORIGIN", "http://localhost:3000")]
else:
    origins = [o.strip() for o in origins_raw.split(",") if o.strip()]
app.add_middleware(
    CORSMiddleware,
    allow_origins=origins,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

# register event handlers
app.add_event_handler("startup", onStartup)
app.add_event_handler("shutdown", onShutdown)

# request logging + request id propagation
app.add_middleware(RequestLogMiddleware)

# Session (cookie-based) for Web
app.add_middleware(
    SessionMiddleware,
    secret_key=config["AUTH"]["secret_key"],
    session_cookie=config["AUTH"].get("session_cookie", "sid"),
    same_site="lax",
    https_only=os.getenv("ENV", "dev").lower() == "prod",
    max_age=config["AUTH"].getint("token_expire", 3600),
)

# load routers
logger.info("router load start")
# Optional: disable demo/example routers via config
disable_demo_routes = False
try:
    disable_demo_routes = config["SERVER"].getboolean("disable_demo_routes", False)
except Exception:
    disable_demo_routes = False

for _, moduleName, _ in pkgutil.iter_modules(router.__path__, router.__name__ + "."):
    # Skip demo TransactionRouter when disabled
    if disable_demo_routes and moduleName.endswith(".TransactionRouter"):
        continue
    module = importlib.import_module(moduleName)
    if hasattr(module, "router"):
        app.include_router(module.router)
logger.info("router load done")


@app.exception_handler(Exception)
async def globalExceptionHandler(request: Request, exc: Exception):
    return JSONResponse(
        status_code=500,
        content=errorResponse(message=str(exc), result={"path": request.url.path}),
    )

