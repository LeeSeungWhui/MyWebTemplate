# 코딩 스타일 가이드 (정규화 버전)

이 문서는 앞으로 이 프로젝트(및 비슷한 구조의 프론트엔드)에서  
코드 짤 때 항상 지켜야 하는 **공통 코딩 규칙의 기준선**이다.

- 기능 구현 1차 → 이 문서를 염두에 두고 작성
- 기능 완료 후 2차 → 이 문서를 기준으로 정리/리팩터링

사람도, AI도 모두 이 규칙을 기본값으로 삼는다.

---

## 0. 코딩 철학

> 템플릿은 정형화, 로직은 눈에 보이게, 추상화는 최소, 가독성이 젤 중요

- 너무 똑똑해 보이려는 추상화 ❌
- 한 줄 아트 코드 ❌
- 의미 없는 함수 쪼개기 ❌

이 세 가지를 피하는 것만으로도 코드 퀄리티 대부분이 정리된다.

---

## 1. 페이지 구조와 책임 분리

### 1.1 기본 템플릿: `initData / page / view`

- 각 페이지(라우트 폴더)는 기본적으로 세 파일을 가진다.
  - `initData.jsx`
  - `page.jsx`
  - `view.jsx`

#### `initData.jsx`

- 페이지 모드, 엔드포인트, 초기 설정 등 **정적인 정보만** 정의한다.
- 예: `PAGE_MODE`, API 경로 배열, 상수들.
- 이 파일 안에서는 **실제 API 호출·상태 관리 금지**.

#### `page.jsx`

- Next.js 라우트 엔트리(서버 컴포넌트) 역할.
- 할 일:
  - `initData.jsx`에서 설정을 읽는다.
  - SSR이 필요할 때만 서버에서 데이터를 미리 조회한다.
  - 최종적으로 `view.jsx`를 호출하면서 props로 데이터/설정을 넘긴다.
- 하지 말아야 할 일:
  - 복잡한 상태/이벤트/뷰 로직을 직접 들고 있지 않는다.
  - useState/useEffect 등 클라이언트 훅 사용하지 않는다.

#### `view.jsx`

- `"use client";`로 시작하는 클라이언트 컴포넌트.
- 페이지의 **실질적인 중심**:
  - 상태 관리
  - 이벤트 처리
  - 사용자 인터랙션
  - 실제 JSX 렌더링
- 이 파일 하나만 봐도 “이 페이지가 뭘 하는지” 파악 가능해야 한다.

### 1.2 도메인 vs 공통 코드

- 도메인 전용 로직은 그 도메인 폴더 안에서 끝낸다.
- **애매하면 공통 util로 뺄 생각을 하지 않는다.**
- 공통 모듈로 올릴 기준:
  - 이름만 봐도 역할이 바로 보이고
  - 실제로 **3군데 이상**에서 재사용되는 경우.

---

## 2. 상태 관리와 전역 스토어

### 2.1 상태 관리 원칙

- 도메인 데이터(리스트, 상세, 검색 조건 등)는
  - 객체/리스트 기반 상태(EasyObj/EasyList류)를 우선 사용한다.
- `useState`는 다음에만 사용:
  - 토글/여닫기
  - 탭/선택된 항목
  - 로딩 플래그
  - 간단한 UI용 임시 값
- `useRef` 사용 기준:
  - 포커스/스크롤 제어
  - 외부 라이브러리/DOM과 연동이 필요한 경우
  - 단순 값 저장을 위한 남용 금지.

### 2.2 고급 훅 사용 규칙 (`useCallback`, `useMemo`)

- “습관성 최적화”로 쓰지 않는다.
- 아래 상황 중 하나일 때만 사용을 고려한다.
  - 자식 컴포넌트에 콜백/값을 넘길 때, deps 안정이 실제로 중요할 때.
  - 계산 비용이 아주 크고, 동일 계산을 여러 번 반복하는 구조일 때.
- 조금이라도 “굳이?” 싶은 경우 → **사용하지 않는다.**

### 2.3 전역 스토어 사용 규칙

- 전역 상태는 별도 스토어 모듈에서만 관리한다.
- 컴포넌트에서는 스토어가 제공하는 **전용 훅**만 사용한다.
  - 예: `useGlobalUi`, `useUser`, `useSharedData` 등.
- 스토어 구현 내부에 직접 접근하거나, 마음대로 필드를 추가·삭제하지 않는다.

---

## 3. 추상화와 유틸 함수

### 3.1 추상화 기준

- 템플릿은 정형화하되, **로직은 눈에 보이게** 작성한다.
- 다음과 같은 코드는 지양한다.
  - `applyFieldMapping(config, schema, options)`처럼  
    읽었을 때 도메인 의미가 전혀 안 보이는 제너릭 헬퍼.
  - 한 파일에 범용 유틸 10개씩 쌓아두는 스타일.

### 3.2 공통 함수 분리 규칙

- 공통 함수로 뺄 때 체크리스트:
  1. **이름만 보고 역할이 바로 이해되는가?**
  2. 같은 로직이 최소 3군데 이상에서 진짜로 반복되는가?
- 둘 중 하나라도 아니면 그대로 둔다.

### 3.3 함수 쪼개기

- 1~3줄짜리 함수는:
  - 최소 3군데 이상에서 재사용되지 않는 한 굳이 분리하지 않는다.
- 함수를 쪼갠 뒤에
  - 가독성이 올라가면 OK
  - 호출 계층만 늘어서 더 헷갈리면 다시 합친다.

### 3.4 얕은 별칭(shallow alias) 금지

- 단순 프로퍼티/인덱스 별칭은 만들지 않는다.
  - 금지 예시
    - `const resultData = dataObj.result;`
    - `const first = list[0];`
    - `const name = row.name;`
  - 가능하면 그대로 `dataObj.result`, `list[0]`, `row.name`처럼 사용한다.
- 허용하는 경우
  - **여러 필드를 조합하거나 가공해서** 새 의미를 만들 때
    - `const totalErrorCount = row.errorCnt + row.missingCnt;`
    - `const isValidRange = from && to && from <= to;`
  - 도메인 의미를 분명히 드러내는 계산/변환 결과일 때
    - 예: 상태 코드 → 라벨 맵핑 결과 등
- 구조 분해 할당도 같은 규칙을 따른다.
  - 여러 필드를 한꺼번에 꺼내는 용도로는 허용하지만,
    - `const { result: resultData } = dataObj;`처럼 이름만 바꾸는 별칭은 지양한다.

---

## 4. 표현식과 조건문 스타일

### 4.1 삼항 연산자

- 삼항 연산자는 **한 단계까지만 허용**.
  - 예: `const label = isError ? '오류' : '정상';`
- 삼항 안에 또 삼항, 복잡한 연산이 들어가면 `if / else`로 풀어 쓴다.

### 4.2 논리 연산자 트릭

- `cond && doSomething()` 패턴은 최소한으로만 쓴다.
- 읽기 좋은 스타일 우선:
  - `if (!cond) return;`
  - `if (cond) { doSomething(); }`

### 4.3 조건 이름 붙이기

- 조건이 복잡해지면 먼저 변수에 이름을 붙인다.

  ```js
  const isValidRange = fromDate && toDate && fromDate <= toDate;
  if (!isValidRange) {
    // ...
  }
  ```

- “읽으면서 뇌를 두 번 접어야 이해되는 조건”이면 무조건 나눈다.

---

## 5. 네이밍 규칙

### 5.0 공통 네이밍 합의 (언어 무관)

- 변수/함수/메서드는 기본적으로 `camelCase`를 사용한다. (Python도 동일 적용)
- 언더스코어(`_`) 네이밍은 지양한다. 기존 라이브러리 시그니처나 외부 스펙 준수 시에만 예외적으로 허용한다.
- 클래스/컴포넌트 이름은 항상 대문자로 시작하는 PascalCase를 사용한다.
- 약칭/축약은 의미가 모호하면 쓰지 않는다. (예: `cfg` 대신 `config`, `svc` 대신 `service`)

### 5.1 변수/상태 이름

- 루프 인덱스(i, index) 말고는 **한 글자 변수 금지**.
  - `r`, `d`, `arr`, `obj` 같은 이름 사용하지 않는다.
- 데이터/상태는 역할이 드러나게:
  - `list`, `row`, `item`, `detail`, `result`, `filterState`, `modData` 등.

### 5.2 컴포넌트/파일 이름

- React 컴포넌트 파일: PascalCase (`ResumeRender.jsx`, `FilterBar.jsx`).
- 페이지 템플릿 파일: 라우트 폴더 하위에 소문자 예약 이름 사용.
  - `page.jsx`, `layout.jsx`, `route.js`, `initData.jsx`, `view.jsx`.
- 파일명과 기본 export 컴포넌트 이름은 가능하면 일치시킨다.

---

## 6. JSX와 파일 레이아웃

### 6.1 .jsx 파일 구조

- 최상단: `import` 구문.
- 그 다음: 바로 컴포넌트/함수 선언.
- 지양할 것:
  - 최상단에 거대한 상수/배열/객체를 쌓아두는 것.
  - 파일 레벨 전역 변수/상태.

### 6.2 설정/스펙 분리

- 큰 설정 객체나 스펙 의미가 있는 데이터는 별도 모듈로 분리한다.
  - 예: `fieldSpecs.mjs`, `formConfig.mjs` 등.
- 설정 파일은 “반복되는 패턴을 줄이는 용도”까지만 사용한다.
  - 중요한 화면 흐름(섹션 순서, 헤더 구조, 버튼 역할 등)은  
    그대로 JSX 코드에 남겨둔다.

### 6.3 서브 컴포넌트 위치

- 특정 페이지에서만 쓰는 컴포넌트:
  - 같은 페이지 폴더(또는 인접 파일) 안에 둔다.
- 여러 페이지에서 재사용될 수 있는 컴포넌트:
  - 공용 컴포넌트 폴더(예: `lib/component`)로 승격을 검토한다.

### 6.4 페이지 뷰(view.jsx) 구현 스타일

- 한 페이지에는 **메인 뷰 컴포넌트 하나**를 두고, 그 안에서 도메인 흐름이 위→아래로 자연스럽게 읽히게 만든다.
  - 예시 구조 ( `app/demo/resumeUpload/view.jsx` 스타일 ):
    - 상단: 상수, EasyObj/EasyList, 훅(`useState`, `useRef`, `useEffect` cleanup 등) 선언
    - 중간: 도메인 이름이 붙은 헬퍼/이벤트 함수 (`acceptFile`, `onUpload`, `resolvePdfUrl` 등)
    - 하단: `return (…)` 안에서 JSX 렌더링
- 이 페이지(view)에서만 쓰는 헬퍼/이벤트 함수는
  - 별도 파일·전역 유틸로 빼지 말고 **컴포넌트 내부에 JSDoc 주석과 함께 정의**하는 것을 우선으로 한다.
- 서브 컴포넌트로 쪼갤 기준:
  - JSX가 너무 길어서 “눈으로 스크롤하며 읽기 힘들어졌을 때”,
  - 혹은 동일한 UI 블록이 여러 페이지에서 반복될 때만 분리한다.

### 6.5 한 파일당 하나의 컴포넌트

- 일반 컴포넌트 파일(PascalCase `.jsx`, 예: `ResumeRender.jsx`, `FilterBar.jsx`)은
  - **기본적으로 한 파일당 하나의 React 컴포넌트**만 export 한다.
  - 서브 컴포넌트가 필요하면 `app/demo/SomeComponent/SubPart.jsx`처럼 별도 파일로 분리한다.
- 예외:
  - `view.jsx`, `page.jsx`처럼 페이지 템플릿 파일은
    - 메인 뷰 컴포넌트 하나만 export 하되,
    - 파일 내부에 도메인 헬퍼/이벤트 함수는 자유롭게 둘 수 있다.
    - 정말 필요한 경우에만 작은 서브 컴포넌트를 내부에 둘 수 있지만,
      그 경우에도 “가독성이 올라가는지”를 기준으로 판단한다.

---

## 7. 에러·로딩·알림 처리

### 7.1 일관된 처리

- `console.error`만 찍고 끝내는 코드 금지.
- 사용자에게 보여주는 메시지는 전부 공통 UI 훅/컴포넌트를 사용:
  - 로딩: 전역 로딩 상태 또는 공통 로딩 컴포넌트.
  - 에러: Alert/Toast 등 통일된 패턴.
  - 확인: Confirm 다이얼로그.

### 7.2 에러 핸들링 패턴

- try/catch 내부:
  - 로그는 `console.error` 또는 로깅 유틸 하나로 통일.
  - 사용자 메시지는 공용 Alert/Toast 사용.
- 가능하면 **early return** 패턴을 사용해 예외 케이스를 먼저 잘라낸다.

---

## 8. 주석 규칙

### 8.1 파일 헤더

- 모든 페이지 템플릿 파일 및 주요 컴포넌트 파일 상단에는 헤더 주석을 단다.

  ```jsx
  /**
   * 파일명: demo/resumeList/view.jsx
   * 설명: /demo/resumeList 페이지 CSR 뷰
   * 작성자: LSH
   * 갱신일: 2025-01-01
   */
  ```

- 내용은 가능한 한 **한글**로 적는다.

### 8.2 함수/컴포넌트 헤더

- 외부에서 재사용되는 함수/컴포넌트에는 JSDoc 스타일 주석을 붙인다.

  ```jsx
  /**
   * @description 이력서 결과 목록을 렌더링한다.
   * @param {Object} props
   */
  const ResumeListView = (props) => { … };
  ```

- 내부에서만 쓰는 짧은 헬퍼는 꼭 필요하지 않으면 생략 가능.

### 8.3 유지 원칙

- 구현이 바뀌면 주석도 함께 수정한다.
- 새로운 파일/함수를 추가할 때는 **헤더 주석부터 작성**하는 습관을 유지한다.

---

## 9. 스타일(CSS)과 UI

- 우선 Tailwind 유틸 클래스와 프로젝트 공통 유틸 클래스를 사용한다.
- 반복되는 스타일만 CSS 모듈/공용 클래스 형태로 추출한다.
- 인라인 스타일은 특별한 이유가 있을 때만 사용한다.

---

## 10. 작업 플로우에서의 사용 방법

1. **기능 구현 단계**
   - 이 규칙을 거칠게만 지키면서 먼저 동작을 맞춘다.
   - 구조/책임 분리(1장)와 네이밍/전역 사용(5·6장)만 특히 신경 쓴다.
2. **정리·리팩터링 단계**
   - 기능이 돌아가면 이 문서를 체크리스트처럼 다시 훑으면서 정리한다.
   - 불필요한 추상화/아트 코드/쪼개기를 제거하고,
     구조와 가독성을 최종적으로 다듬는다.

이 문서는 “프로젝트마다 조금씩 달라지는 세부 구현”이 아니라  
**앞으로의 모든 프론트엔드 작업에 공통으로 적용할 기본 규칙**을 정의한다.  
새로운 패턴을 도입하거나 기존 규칙을 바꾸면, 이 문서도 반드시 함께 갱신한다.
