# 코딩 스타일 가이드 (정규화 버전)

이 문서는 앞으로 이 프로젝트(및 비슷한 구조의 프론트엔드)에서  
코드 짤 때 항상 지켜야 하는 **공통 코딩 규칙의 기준선**이다.

- 기능 구현 1차 → 이 문서를 염두에 두고 작성
- 기능 완료 후 2차 → 이 문서를 기준으로 정리/리팩터링

사람도, AI도 모두 이 규칙을 기본값으로 삼는다.

---

## 0. 코딩 철학

> 템플릿은 정형화, 로직은 눈에 보이게, 추상화는 최소, 가독성이 젤 중요

- 너무 똑똑해 보이려는 추상화 ❌
- 한 줄 아트 코드 ❌
- 의미 없는 함수 쪼개기 ❌

이 세 가지를 피하는 것만으로도 코드 퀄리티 대부분이 정리된다.

---

## 1. 페이지 구조와 책임 분리

### 1.1 기본 템플릿: `initData / page / view`

- 각 페이지(라우트 폴더)는 기본적으로 세 파일을 가진다.
  - `initData.jsx`
  - `page.jsx`
  - `view.jsx`
- 각 페이지(라우트 폴더)는 다국어 리소스 파일을 함께 가진다.
  - `lang.ko.js` (필수)
  - `lang.<locale>.js` (선택, 확장 시)

#### `lang.ko.js` (필수)

- 라우트 폴더 기준의 UI 문구 리소스 파일이다.
  - 예: `app/sample/portfolio/lang.ko.js`
- `initData/page/view`에서 사용자에게 보이는 텍스트는 이 파일(또는 공통 i18n 파일)에서 가져온다.
- 하드코딩 금지 대상:
  - 제목/설명/버튼 라벨/placeholder/empty/error 안내 문구
- `lib/component` 공용 컴포넌트 기본 문구도 같은 기준을 적용한다.
  - 기본값 문자열은 `app/common/i18n/lang.ko.js` 등 공통 i18n 리소스에서 가져온다.
  - 컴포넌트 호출부에서 `props`로 문구를 덮어쓸 수 있게 설계한다.
- 예외(하드코딩 허용):
  - 개발용 로그 문구
  - 코드/프로토콜/헤더 키/상태 코드 같은 기술 상수
  - 접근성 속성의 매우 짧은 보조 문구(가능하면 리소스화 권장)

예시:

```js
// app/sample/example/lang.ko.js
export const LANG_KO = {
  title: "샘플 제목",
  submit: "저장하기",
};
```

#### `initData.jsx`

- 페이지 모드, 엔드포인트, 초기 설정 등 **정적인 정보만** 정의한다.
- 예: `PAGE_MODE`, API 경로 배열, 상수들.
- 이 파일 안에서는 **실제 API 호출·상태 관리 금지**.
- 페이지 전용 문구는 `lang.ko.js`를 import해서 조합한다.

#### `page.jsx`

- Next.js 라우트 엔트리(서버 컴포넌트) 역할.
- 할 일:
  - `initData.jsx`에서 설정을 읽는다.
  - SSR이 필요할 때만 서버에서 데이터를 미리 조회한다.
  - 최종적으로 `view.jsx`를 호출하면서 props로 데이터/설정을 넘긴다.
- 하지 말아야 할 일:
  - 복잡한 상태/이벤트/뷰 로직을 직접 들고 있지 않는다.
  - useState/useEffect 등 클라이언트 훅 사용하지 않는다.

#### `view.jsx`

- `"use client";`로 시작하는 클라이언트 컴포넌트.
- 페이지의 **실질적인 중심**:
  - 상태 관리
  - 이벤트 처리
  - 사용자 인터랙션
  - 실제 JSX 렌더링
- 이 파일 하나만 봐도 “이 페이지가 뭘 하는지” 파악 가능해야 한다.
- 사용자 노출 텍스트 하드코딩 대신 `lang.ko.js`/공통 i18n 리소스를 참조한다.

### 1.2 도메인 vs 공통 코드

- 도메인 전용 로직은 그 도메인 폴더 안에서 끝낸다.
- **애매하면 공통 util로 뺄 생각을 하지 않는다.**
- 공통 모듈로 올릴 기준:
  - 이름만 봐도 역할이 바로 보이고
  - 실제로 **3군데 이상**에서 재사용되는 경우.

### 1.3 `layout.jsx` 사용 규칙 (필요할 때만)

- 기본은 `initData / page / view` 3개로 끝낸다.
- `layout.jsx`는 “공통 UI를 묶는 용도”로만 쓴다.
  - 예: Header/Footer/컨테이너/Provider, 공통 접근성 구조(landmark) 등
  - **페이지마다 무조건 만들지 않는다.**
- 하위 페이지에서 레이아웃이 확실히 달라지는 경우에만, 그 하위 경로에 `layout.jsx`를 추가한다.
  - 예: 헤더가 없는 풀스크린 편집 화면, 특정 플로우 전용 네비/스텝퍼가 필요한 경우
- 같은 레이아웃을 공유해야 하는 페이지가 많아지면, 하위 경로에 `layout.jsx`를 두어 상속 구조로 관리한다.
- `AppLayout` 같은 wrapper 컴포넌트로 매 페이지를 감싸는 패턴은 지양한다.
  - 공통 Header는 `layout.jsx`에서 한 번만 렌더링하고, 개별 `page.jsx`/`view.jsx`는 화면 로직에 집중한다.
- `layout.jsx`는 가능한 서버 컴포넌트로 유지한다.
  - 클라이언트 상태/이벤트가 필요하면 `ClientLayout.jsx`로 분리해서 `layout.jsx`에서 감싸는 방식으로 처리한다.
  - 경로 기반 분기(예: `/component`에서 Header 숨김)는 `ClientLayout.jsx`에서 처리한다.
  - `ClientLayout.jsx`는 전역 1개만 두고, 하위 레이아웃 변경은 `layout.jsx`로 처리한다.
  - 라우트 그룹은 사용하지 않는다. 경로 기준 분기는 `ClientLayout.jsx`에서 처리한다.

---

## 2. 상태 관리와 전역 스토어

### 2.1 상태 관리 원칙

- 기본 정책:
  - 도메인 데이터(리스트, 상세, 검색 조건 등)와 페이지 UI 상태(토글/탭/선택/로딩/임시 입력값)는 `EasyObj/EasyList`를 기본으로 사용한다.
  - 검색/필터는 `draft`와 `applied`를 분리해 관리하는 것을 권장한다.
- `useState` 사용 정책:
  - 원칙적으로 사용하지 않는다.
  - 아래처럼 진짜 불가피한 경우에만 예외적으로 사용한다.
    - 외부 라이브러리가 제어 상태를 강제하는 경우
    - 컴포넌트 내부의 초국소/일시 상태를 `EasyObj`로 올리는 것이 오히려 복잡도를 높이는 경우
  - 레거시/점진 전환(예: `LEGACY_TRANSITION`) 사유는 예외로 허용하지 않는다.
  - 예외 사용 시 `docs/frontend-web/rule-gate-usestate-allowlist.txt`에 사유를 명시하고 룰게이트 검증을 통과해야 한다.
- `useRef` 사용 기준:
  - 포커스/스크롤 제어
  - 외부 라이브러리/DOM과 연동이 필요한 경우
  - 단순 값 저장을 위한 남용 금지.

### 2.2 고급 훅 사용 규칙 (`useCallback`, `useMemo`)

- “습관성 최적화”로 쓰지 않는다.
- 아래 상황 중 하나일 때만 사용을 고려한다.
  - 자식 컴포넌트에 콜백/값을 넘길 때, deps 안정이 실제로 중요할 때.
  - 계산 비용이 아주 크고, 동일 계산을 여러 번 반복하는 구조일 때.
- 조금이라도 “굳이?” 싶은 경우 → **사용하지 않는다.**

### 2.3 전역 스토어 사용 규칙

- 전역 상태는 별도 스토어 모듈에서만 관리한다.
- 컴포넌트에서는 스토어가 제공하는 **전용 훅**만 사용한다.
  - 예: `useGlobalUi`, `useUser`, `useSharedData` 등.
- 스토어 구현 내부에 직접 접근하거나, 마음대로 필드를 추가·삭제하지 않는다.

### 2.4 세션/로그인 정책 (필수)

- 인증 토큰은 프론트 JS에서 직접 만지지 않는다.
  - `access_token`/`refresh_token`은 httpOnly 쿠키이며, 클라이언트 코드에서 읽을 수 없다.
- “세션의 단일 소스”는 `GET /api/bff/api/v1/auth/me` 응답이다.
  - 헤더/페이지에서 로그인 상태가 필요하면 이 값을 기준으로 처리한다.
- Web 로그인 응답은 쿠키 발급 성공 여부만 확인하고, 사용자 상태는 즉시 `/api/bff/api/v1/auth/me`로 재조회해 동기화한다.
  - 로그인/리프레시 응답 본문의 `accessToken`/`refreshToken` 사용은 금지한다.
- `useSharedStore().user/userJson`은 “UX를 위한 캐시(optimistic)”다.
  - 세션 확인이 끝나기 전이라도 캐시가 있으면 먼저 표시할 수 있다.
  - 단, 실제 권한 판단/보호 라우팅은 반드시 세션 확인(또는 401 처리)로 수렴해야 한다.
- API 401 처리 원칙:
  - `apiRequest`가 401을 받으면 `/login?next=...`로 이동시킨다(미들웨어가 `nx` 쿠키로 정리).
- 로그인 불필요(public) API 호출 규칙:
  - 로그인 없이도 호출 가능한 API는 호출부에서 `authless` 옵션을 명시한다.
    - 권장: `apiJSON('/notice/list', { method: 'GET' }, { authless: true })`
    - 축약: `apiJSON('/notice/list', { method: 'GET' }, 'authless')`
  - `authless`의 의미는 “CSR에서 401 수신 시 자동 `/login` 리다이렉트 생략”이다.
    - BFF 프록시/리프레시를 건너뛰는 서버 신호가 아니다.
  - `csrf: 'skip'`은 현재 인증 우회 신호로 사용하지 않는다.
    - 새 코드에서는 `csrf: 'skip'` 패턴을 추가하지 않는다.

### 2.5 API 통신 규칙 (필수)

- 백엔드와 통신(SSR/CSR)은 **lib에 이미 구현된 유틸만 사용**한다.
  - JSON API: `apiJSON` (권장: `apiGet/apiPost/...`)
  - 특수 케이스(다운로드/stream 등): `apiRequest`
  - 파일 업로드(multipart/form-data): `useEasyUpload`
    - 업로드 유틸은 인증 우회용 헤더(`X-CVFIT-AUTHLESS`)를 자동 주입하지 않는다.
- 금지(발견 시 리팩터링 대상):
  - 페이지/컴포넌트에서 `fetch()` 직접 호출
  - `res.json()` / `JSON.parse()`로 응답을 직접 파싱
    - 백엔드 응답은 “깨진 JSON/중첩 JSON 문자열”이 섞일 수 있으니, `apiJSON` 내부 보정 로직을 우회하지 않는다.
- 예시(권장)

  ```js
  import { apiJSON } from '@/app/lib/runtime/api';

  const payload = await apiJSON('/resume/upload', { method: 'POST', body: input });
  ```

  ```js
  import useEasyUpload from '@/app/lib/hooks/useEasyUpload';

  const payload = await useEasyUpload(file, { fileUploadUrl: '/resume/upload' });
  ```

---

## 3. 추상화와 유틸 함수

### 3.1 추상화 기준

- 템플릿은 정형화하되, **로직은 눈에 보이게** 작성한다.
- 다음과 같은 코드는 지양한다.
  - `applyFieldMapping(config, schema, options)`처럼  
    읽었을 때 도메인 의미가 전혀 안 보이는 제너릭 헬퍼.
  - 한 파일에 범용 유틸 10개씩 쌓아두는 스타일.

### 3.2 공통 함수 분리 규칙

- 공통 함수로 뺄 때 체크리스트:
  1. **이름만 보고 역할이 바로 이해되는가?**
  2. 같은 로직이 최소 3군데 이상에서 진짜로 반복되는가?
- 둘 중 하나라도 아니면 그대로 둔다.

### 3.3 함수 쪼개기

- 1~3줄짜리 함수는:
  - 최소 3군데 이상에서 재사용되지 않는 한 굳이 분리하지 않는다.
- 함수를 쪼갠 뒤에
  - 가독성이 올라가면 OK
  - 호출 계층만 늘어서 더 헷갈리면 다시 합친다.

### 3.4 얕은 별칭(shallow alias) 금지

- 단순 프로퍼티/인덱스 별칭은 만들지 않는다.
  - 금지 예시
    - `const resultData = dataObj.result;`
    - `const first = list[0];`
    - `const name = row.name;`
  - 가능하면 그대로 `dataObj.result`, `list[0]`, `row.name`처럼 사용한다.
- 허용하는 경우
  - **여러 필드를 조합하거나 가공해서** 새 의미를 만들 때
    - `const totalErrorCount = row.errorCnt + row.missingCnt;`
    - `const isValidRange = from && to && from <= to;`
  - 도메인 의미를 분명히 드러내는 계산/변환 결과일 때
    - 예: 상태 코드 → 라벨 맵핑 결과 등
- 구조 분해 할당도 같은 규칙을 따른다.
  - 여러 필드를 한꺼번에 꺼내는 용도로는 허용하지만,
    - `const { result: resultData } = dataObj;`처럼 이름만 바꾸는 별칭은 지양한다.

---

## 4. 표현식과 조건문 스타일

### 4.1 삼항 연산자

- 삼항 연산자는 **한 단계까지만 허용**.
  - 예: `const label = isError ? '오류' : '정상';`
- 삼항 안에 또 삼항, 복잡한 연산이 들어가면 `if / else`로 풀어 쓴다.

### 4.2 논리 연산자 트릭

- `cond && doSomething()` 패턴은 최소한으로만 쓴다.
- 읽기 좋은 스타일 우선:
  - `if (!cond) return;`
  - `if (cond) { doSomething(); }`

### 4.3 조건 이름 붙이기

- 조건이 복잡해지면 먼저 변수에 이름을 붙인다.

  ```js
  const isValidRange = fromDate && toDate && fromDate <= toDate;
  if (!isValidRange) {
    // ...
  }
  ```

- “읽으면서 뇌를 두 번 접어야 이해되는 조건”이면 무조건 나눈다.

---

## 5. 네이밍 규칙

### 5.1 변수/상태 이름

- 루프 인덱스(i, index) 말고는 **한 글자 변수 금지**.
  - `r`, `d`, `arr`, `obj` 같은 이름 사용하지 않는다.
- 데이터/상태는 역할이 드러나게:
  - `list`, `row`, `item`, `detail`, `result`, `filterState`, `modData` 등.

### 5.2 컴포넌트/파일 이름

- React 컴포넌트 파일: PascalCase (`ResumeRender.jsx`, `FilterBar.jsx`).
- 페이지 템플릿 파일: 라우트 폴더 하위에 소문자 예약 이름 사용.
  - `page.jsx`, `layout.jsx`, `route.js`, `initData.jsx`, `view.jsx`.
- 파일명과 기본 export 컴포넌트 이름은 가능하면 일치시킨다.

---

## 6. JSX와 파일 레이아웃

### 6.1 .jsx 파일 구조

- 최상단: `import` 구문.
- 그 다음: 바로 컴포넌트/함수 선언.
- import 블록 무결성 유지:
  - `'use client'` 같은 지시어 이후에는 import를 연속 배치한다.
  - 실행문(`const`, 함수 선언/호출 등) 이후 정적 import 재선언 금지(`import()` 동적 로딩은 예외).
- 지양할 것:
  - 최상단에 거대한 상수/배열/객체를 쌓아두는 것.
  - 파일 레벨 전역 변수/상태.

### 6.2 설정/스펙 분리

- 큰 설정 객체나 스펙 의미가 있는 데이터는 별도 모듈로 분리한다.
  - 예: `fieldSpecs.mjs`, `formConfig.mjs` 등.
- 분리된 파일이 “한 세트”인 경우, 같은 폴더에 묶어서 한눈에 알아보게 만든다.
  - 예: `app/component/CVIcon/CVIcon.jsx` + `app/component/CVIcon/figmaIconMap.js`
  - 외부 import 경로는 한 군데(엔트리)로 유지한다.
    - 예: `app/component/CVIcon.jsx`에서 `./CVIcon/CVIcon`로 위임(re-export)
- 설정 파일은 “반복되는 패턴을 줄이는 용도”까지만 사용한다.
  - 중요한 화면 흐름(섹션 순서, 헤더 구조, 버튼 역할 등)은  
    그대로 JSX 코드에 남겨둔다.

### 6.3 서브 컴포넌트 위치

- 특정 페이지에서만 쓰는 컴포넌트:
  - 같은 페이지 폴더(또는 인접 파일) 안에 둔다.
- 여러 페이지에서 재사용될 수 있는 컴포넌트:
  - 공용 컴포넌트 폴더(예: `lib/component`)로 승격을 검토한다.

### 6.4 페이지 뷰(view.jsx) 구현 스타일

- 한 페이지에는 **메인 뷰 컴포넌트 하나**를 두고, 그 안에서 도메인 흐름이 위→아래로 자연스럽게 읽히게 만든다.
  - 예시 구조 ( `app/sample/resumeUpload/view.jsx` 스타일 ):
    - 상단: 상수, EasyObj/EasyList, 훅(`useState`, `useRef`, `useEffect` cleanup 등) 선언
    - 중간: 도메인 이름이 붙은 헬퍼/이벤트 함수 (`acceptFile`, `onUpload`, `resolvePdfUrl` 등)
    - 하단: `return (…)` 안에서 JSX 렌더링
- 이 페이지(view)에서만 쓰는 헬퍼/이벤트 함수는
  - 별도 파일·전역 유틸로 빼지 말고 **컴포넌트 내부에 JSDoc 주석과 함께 정의**하는 것을 우선으로 한다.
- 서브 컴포넌트로 쪼갤 기준:
  - JSX가 너무 길어서 “눈으로 스크롤하며 읽기 힘들어졌을 때”,
  - 혹은 동일한 UI 블록이 여러 페이지에서 반복될 때만 분리한다.

### 6.5 한 파일당 하나의 컴포넌트

- 일반 컴포넌트 파일(PascalCase `.jsx`, 예: `ResumeRender.jsx`, `FilterBar.jsx`)은
  - **기본적으로 한 파일당 하나의 React 컴포넌트**만 export 한다.
  - 서브 컴포넌트가 필요하면 `app/sample/SomeComponent/SubPart.jsx`처럼 별도 파일로 분리한다.
- 예외(공용 컴포넌트 파일 내부 소형 컴포넌트 허용):
  - 같은 파일에서만 쓰는 내부 UI 조각은 파일 내부에 둘 수 있다.
  - 조건:
    - `export` 하지 않는다.
    - 약 30줄 내외의 단순 표현 컴포넌트(`Arrow`, `TabItem`, `ModalHeader` 등)로 제한한다.
    - 동일 패턴이 2개 이상 파일에서 반복되면 별도 컴포넌트로 분리한다.
- 추가 예외:
  - `view.jsx`, `page.jsx`처럼 페이지 템플릿 파일은
    - 메인 뷰 컴포넌트 하나만 export 하되,
    - 파일 내부에 도메인 헬퍼/이벤트 함수는 자유롭게 둘 수 있다.
    - 정말 필요한 경우에만 작은 서브 컴포넌트를 내부에 둘 수 있지만,
      그 경우에도 “가독성이 올라가는지”를 기준으로 판단한다.

---

## 7. 에러·로딩·알림 처리

### 7.1 일관된 처리

- `console.error`만 찍고 끝내는 코드 금지.
- 사용자에게 보여주는 메시지는 전부 공통 UI 훅/컴포넌트를 사용:
  - 로딩: 전역 로딩 상태 또는 공통 로딩 컴포넌트.
  - 에러: Alert/Toast 등 통일된 패턴.
  - 확인: Confirm 다이얼로그.

### 7.2 에러 핸들링 패턴

- try/catch 내부:
  - 로그는 `console.error` 또는 로깅 유틸 하나로 통일.
  - 사용자 메시지는 공용 Alert/Toast 사용.
- 가능하면 **early return** 패턴을 사용해 예외 케이스를 먼저 잘라낸다.

---

## 8. 주석 규칙

### 8.1 파일 헤더

- 모든 페이지 템플릿 파일 및 주요 컴포넌트 파일 상단에는 헤더 주석을 단다.(작성자 반드시 LSH로)

  ```jsx
  /**
   * 파일명: sample/resumeList/view.jsx
   * 설명: /sample/resumeList 페이지 CSR 뷰
   * 작성자: LSH
   * 갱신일: 2025-01-01
   */
  ```

- 내용은 가능한 한 **한글**로 적는다.

### 8.2 함수/컴포넌트 헤더

- 외부에서 재사용되는 함수/컴포넌트에는 JSDoc 스타일 주석을 붙인다.

  ```jsx
  /**
   * @description 이력서 결과 목록을 렌더링한다.
   * @param {Object} props
   */
  const ResumeListView = (props) => { … };
  ```

- 내부에서만 쓰는 짧은 헬퍼는 꼭 필요하지 않으면 생략 가능.

### 8.3 유지 원칙

- 구현이 바뀌면 주석도 함께 수정한다.
- 새로운 파일/함수를 추가할 때는 **헤더 주석부터 작성**하는 습관을 유지한다.

---

## 9. 스타일(CSS)과 UI

- 우선 Tailwind 유틸 클래스와 프로젝트 공통 유틸 클래스를 사용한다.
- 반복되는 스타일만 CSS 모듈/공용 클래스 형태로 추출한다.
- 인라인 스타일은 특별한 이유가 있을 때만 사용한다.

### 9.1 반응형/해상도 규칙 (공통)

- 기본 원칙은 **유동 레이아웃(반응형) 우선**이다.
  - 모바일/태블릿/일반 데스크톱은 자연스럽게 줄어들고 늘어나는 구조를 먼저 만든다.
- 전역(`app/layout.jsx`, `globals.css`)에 `min-width: 1920px` 같은 고정 폭은 넣지 않는다.
  - 예외: 제품 자체가 “데스크톱 전용 내부툴”로 확정된 경우에만 별도 합의 후 적용.
- 데스크톱 기준 그리드는 `cv-container`(`max-width: 1436px`)를 기본으로 사용한다.
- Figma의 픽셀 고정 치수(예: `520`, `498`, `710`, `347`)가 반드시 필요한 경우:
  - 해당 페이지/섹션에서만 `min-[1468px]:...` 형태로 적용한다.
  - 즉, **1468px 이상에서만 고정 픽셀 매칭**, 그 미만은 반응형 값을 유지한다.
- 새 페이지 구현 시, 반응형 클래스 작성 순서는 아래를 기본으로 한다.
  - 기본(모바일) → `md`/`lg` 보정 → `min-[1468px]`에서 Figma 고정치 적용

---

## 10. 작업 플로우에서의 사용 방법

1. **기능 구현 단계**
   - 이 규칙을 거칠게만 지키면서 먼저 동작을 맞춘다.
   - 구조/책임 분리(1장)와 네이밍/전역 사용(5·6장)만 특히 신경 쓴다.
2. **정리·리팩터링 단계**
   - 기능이 돌아가면 이 문서를 체크리스트처럼 다시 훑으면서 정리한다.
   - 불필요한 추상화/아트 코드/쪼개기를 제거하고,
     구조와 가독성을 최종적으로 다듬는다.
3. **룰게이트 운영/동기화**
   - 실행 모드 기준(`--all`/`--changed`)과 문서 변경 시 동기화 절차는
     `docs/frontend-web/rule-gate-operations.md`를 따른다.
   - 검출/비검출 회귀 기준은
     `docs/frontend-web/rule-gate-regression-cases.md`를 기준으로 유지한다.

이 문서는 “프로젝트마다 조금씩 달라지는 세부 구현”이 아니라  
**앞으로의 모든 프론트엔드 작업에 공통으로 적용할 기본 규칙**을 정의한다.  
새로운 패턴을 도입하거나 기존 규칙을 바꾸면, 이 문서도 반드시 함께 갱신한다.
